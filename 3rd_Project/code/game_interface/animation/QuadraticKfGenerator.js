
/**
 * Class designed to generate a keyframe based parabolic animation. The animation can be generated by two points that must be in the same x-plane.
 */
class QuadraticKfGenerator {


    constructor() {

    }

    /**
    * @method calculateParabolicCoefficients
	* Calculates the coefficients of a parabola formed by the given three points.
    */
    static calculateParabolicCoefficients(x1, y1, x2, y2, x3, y3) {

        let denom = (x1 - x2) * (x1 - x3) * (x2 - x3);
        let A = (x3 * (y2 - y1) + x2 * (y1 - y3) + x1 * (y3 - y2)) / denom;
        let B = (x3 * x3 * (y1 - y2) + x2 * x2 * (y3 - y1) + x1 * x1 * (y2 - y3)) / denom;
        let C = (x2 * x3 * (x2 - x3) * y1 + x3 * x1 * (x3 - x1) * y2 + x1 * x2 * (x1 - x2) * y3) / denom;

        return [A, B, C];
    }

    /**
     * @method calculateParabolicCoefficients
     * Generate keyframes for a parabola that exists in a plane parallel to yOz. This parabola is defined by a startPosition, a endPosition and a height. 
     * It is expected that startPos and endPos have the same x coordinate.
     * @param {Array} startPos                  starting position of the parabolic curve.
     * @param {Array} endPos                    end position of the parabolic curve
     * @param {Float} height                    height of the appex of the curve
     * @param {Float} time                      total time of the animation
     * @param {Integer} keyframeCount           number of keyframes to be generated
     */
    static generateKeyFrames(startPos, endPos, height, time, keyframeCount) {

        let keyframes = [];

        // The z value for the mid point of the parabola (where the appex should be).
        let midPoint = (endPos[2] - startPos[2]) / 2;
        let coefs = this.calculateParabolicCoefficients(startPos[2], startPos[1], startPos[2] + midPoint, height, endPos[2], endPos[1]);

        // Timestep between sucessive keyframes
        let timeStep = time / keyframeCount;
        
        // Z-increment between sucessive keyframes
        let zDelta = (endPos[2] - startPos[2]) / keyframeCount;

        // Starting conditions
        let currentTime = 0;
        let currentZ = startPos[2];

        // Generate the keyframes
        for (let i = 0; i <= keyframeCount; i++) {

            let newTranslation = [0, coefs[0] * currentZ * currentZ + coefs[1] * currentZ + coefs[2] - startPos[1], currentZ - startPos[2]]
            keyframes.push(new KeyFrame(currentTime, newTranslation, [0, 0, 0], [1, 1, 1]))
            currentZ += zDelta;
            currentTime += timeStep;

        }

        return keyframes;

    }


}